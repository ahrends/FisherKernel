function HMM = fit_HMM_simcv(datadir, hmmdir, HMM_name, n_train, n_test, betwgroup_diff, Y_noise, k, cv)
% HMM = fit_HMM_simcv(n_train, n_test, betwgroup_diff, Y_noise, type)
%
% fit a group-level HMM to simulated timecourses using
% simulate_cv_generatetc, either only to the training set or to all
% subjects. 
% This uses a Gaussian observation model with both mean and covariance.
% Wrapper for hmmmar.
% 
% Dependencies:
% HMM-MAR toolbox: https://github.com/OHBA-analysis/HMM-MAR
% 
% Input:
%    HMM_name: root name for output HMMs to be recognised by kernel-builder
%       functions
%    n_train: number of subjects in the training set
%    n_test: number of subjects in the test set
%    betwgroup_diff: scalar for the difference between the training and 
%       test set
%    Y_noise: noise on the target variable
%    k: number of HMM states
%    cv: whether to fit only to the training set or to all subjects
%       (1 for only training subjects, 2 for all subjects)
% 
% Output:
%    HMM: trained HMM struct containing
%       hmm: the estimated model (struct)
%       Gamma: the state probability timecourses (timepoints x k)
%       Xi: joint probability of past and future states conditioned data
%       (timepoints x k x k)
%       vpath: Viterbi path (timepoints x 1 vector)
%       fehist: Free Energy history to check model inference
%
% Christine Ahrends, University of Oxford, 2024

%% Load example data

if ~isdir(hmmdir); mkdir(hmmdir); end

% load simulated data for these parameters:
load([datadir '/X_ntrain' num2str(n_train) '_ntest' num2str(n_test) ...
    '_betwgroupdiff' num2str(betwgroup_diff) '_Ynoise' num2str(Y_noise) '.mat']);

% for file naming consistency:
if cv==1
    cv_char='sep';
elseif cv==2
    cv_char='tog';
end

%% Fit HMM:

% specify options
hmm_options = struct();
hmm_options.order = 0;
hmm_options.covtype = 'full'; %('full' for covariance, 'uniquefull' for no covariance)
hmm_options.zeromean = 0; % (0 to model mean, 1 to model only covariance)
hmm_options.standardise = 0; % not necessary here since timecourses are already standardised
hmm_options.dropstates = 0;
hmm_options.K = k;
hmm_options.useParallel = 0;

% get data for all subjects and data for training subjects
subvec = 1:n_subj;
train_ind = find(subvec<=n_train); % assuming that data are in order (all training subjects, all test subjects), as generated by simulate_cv_generatetc
Xc = cell(n_subj,1);
Tc = cell(n_subj,1);
for n = 1:n_subj
    Xc{n} = X(sum(T(1:n-1))+1:sum(T(1:n)),:);
    Tc{n} = T(n);
end
X_train = Xc(train_ind);
T_train = Tc(train_ind);

% fit HMM
if strcmp(cv_char, 'tog') % if fitting to all subjects
    [HMM.hmm, HMM.Gamma, HMM.Xi, HMM.vpath] = hmmmar(Xc, Tc, hmm_options);
elseif strcmp(cv_char, 'sep') % if fitting only to training subjects
    [HMM.hmm, HMM.Gamma, HMM.Xi, HMM.vpath] = hmmmar(X_train, T_train, hmm_options);
end

save([hmmdir '/' HMM_name '_' cv_char '_n_train' num2str(n_train) '_n_test' num2str(n_test) ...
    '_betwgroup_diff' num2str(betwgroup_diff) '_Y_noise' num2str(Y_noise) '.mat'], "HMM");

end